function [mq,best_segs] = CSI_across_frames(ConfigFile_or_opts, rf_obj, w, directories, img_names,mask_type, quality_type, options)
% Run CSI algorithm across a whole video sequence, specified by directories
% and img_names.
% Parameters: ConfigFile_or_opts: The configuration that can be generated by
%                                 Generate_configs.m, see also
%                                 SegTrack_config.m for an example
%                         rf_obj: The random Fourier feature object stored
%                                 during tracking.
%                              w: each column of w specifies an appearance
%                                 model for a segment track.
%                    directories: The directories of a sequence. Can be
%                                 obtained via parse_dataset.m
%                      img_names: The name of the image for each frame. Can
%                                 be obtained via parse_dataset.m
%                   quality_type: The desired performance measure. See
%                                 /SPT/compute_segment_qualities.m for a list
%                        options: Additional parameters.
%               options.reg_grid: a vector of lambda_1 (Eq. 7) values to be tested.
%            options.weight_grid: a vector of lambda_2 (Eq. 7) values to be tested.
%                                 The algorithm will run a grid search over
%                                 all pairs of values in weight_grid and reg_grid.
%                                 Because of the pre-computations that can
%                                 be re-used, this is faster than just
%                                 running the algorithm multiple times.
%             options.slack_grid: a vector of slack values, same length as
%                                 options.reg_grid. Because of the
%                                 regularization that makes theta smaller than 
%                                 it should be, CSI segments are generally a 
%                                 bit smaller than the object. Setting
%                                 slack_grid appropriately can make the
%                                 performance better. Default to options.reg_grid * 2 - 0.2
%                                 which seem to work well on SegTrack v2
%                                 (NOTE each element in slack_grid
%                                 corresponds to each element in
%                                 reg_grid, there is no 3-way grid search).
%  Fuxin Li, Georgia Institute of Technology, 2013
    if ~isstruct(ConfigFile_or_opts)
        eval(ConfigFile_or_opts);
    else
        SVMSEGMopts = ConfigFile_or_opts;
    end
    DefaultVal({'mask_type','weight_grid','reg_grid'},{SVMSEGMopts.mask_type_test,0.3,0.3});
    DefaultVal('slack_grid',reg_grid * 2 - 0.2);
    if exist('options','var') && ~isempty(options)
        if isfield(options,'weight_grid')
            weight_grid = options.weight_grid;
        end
        if isfield(options,'reg_grid')
            reg_grid = options.reg_grid;
        end
        if isfield(options,'slack_grid')
            slack_grid = options.slack_grid;
        else
            slack_grid = reg_grid * 2 - 0.2;
        end
    end
%    qual_track = zeros(size(w,2),length(img_names));    
    qual_track = cell(length(img_names),1);
    for i=1:length(img_names)
        try
            rmdir([SVMSEGMopts.exp_dir 'MySegmentTracks/' mask_type '/CSI/' directories{i} '/'],'s');
        end
    end
    % OK, this time, 1st stuff is to get the superpixels for everything in
    % this track
    for i=1:length(img_names)
        if (mod(i,10)==0)
            i
        end
        features_cur = get_features(SVMSEGMopts.tracking_features, SVMSEGMopts.measurement_dir, ...
         SVMSEGMopts.scaling_types, mask_type, directories{i}, img_names{i});
        XX1 = rf_featurize(rf_obj, features_cur{1}');
        XX2 = rf_featurize(rf_obj, features_cur{2}');
        allX_test = [XX1 XX2];
        pred = bsxfun(@plus,w(1,:),allX_test * w(2:end,:));
        masks_cur = load([SVMSEGMopts.segment_matrice_dir mask_type '/' directories{i} '/' img_names{i} '.mat']);
        masks = masks_cur.masks;        
        img_ext = get_img_extension([SVMSEGMopts.exp_dir '/JPEGImages/' directories{i} '/' img_names{i}]);
        I = imread([SVMSEGMopts.exp_dir '/JPEGImages/' directories{i} '/' img_names{i} img_ext]);        
        best_segs = false(size(I,1),size(I,2), size(pred,2));
        [sup_size{i}, sup_assignment{i}, scores{i}, bag_ids{i}, Pixels{i}] = generate_superpixels_from_segresults(masks, pred, [], 0.5 * max(pred(:)));
    end
    pairwise_links = cell(length(img_names)-1,1);
    pairwise_backlinks = cell(length(img_names)-1,1);
    % Secondly, get all the superpixel linkages
    if numel(weight_grid) > 1 || weight_grid > 0
        for i=1:length(img_names)-1
            if (mod(i,10)==0)
                i
            end
            num1 = max(Pixels{i+1}(:));
            num2 = max(Pixels{i}(:));
            [cols rows] = meshgrid(1:size(Pixels{i},2), 1:size(Pixels{i},1));
            var = load([SVMSEGMopts.opticalflow_dir '/' directories{i} '/' img_names{i} '_' img_names{i+1} '.mat']);
            pixels_next = interp2(Pixels{i+1}, cols + var.fwflow_vy, rows + var.fwflow_vx, 'nearest');
            pixels_prev = interp2(Pixels{i}, cols + var.bwflow_vy, rows + var.bwflow_vx, 'nearest');
            sumim = pixels_next(:) * num2 + Pixels{i}(:);
            sumim_prev = pixels_prev(:) * num1 + Pixels{i+1}(:);
            % Start from num+1 because we only care about matches. If sth is
            % only present in frame 1 but not frame 2, then we just don't care
            % about it.
            hs = histc(sumim,num2+1:(num2*(num1+1)));
            hs = reshape(hs, num2,num1);
            hs = bsxfun(@rdivide, hs, sum(hs,2) + eps);
            hs(hs<0.05) = 0;
            pairwise_links{i} = sparse(hs);
            hs_prev = histc(sumim_prev, num1+1:(num1*(num2+1)));
            hs_prev = reshape(hs_prev, num1, num2);
            hs_prev = bsxfun(@rdivide, hs_prev, sum(hs_prev,2) + eps);
            hs_prev(hs_prev<0.05) = 0;
            pairwise_backlinks{i} = sparse(hs_prev);
        end
    end
    % Form big optimization problem

    mq = zeros(length(weight_grid), length(reg_grid), size(w,2));
    best_segs = cell(length(weight_grid), length(reg_grid));
    for i=1:length(weight_grid)
        for j=1:length(reg_grid)
            best_segs{i,j} = run_cross_frame_assignment_fb(scores, sup_size, sup_assignment, pairwise_links, pairwise_backlinks, Pixels, reg_grid(j), weight_grid(i), slack_grid(j));
            for ii=1:size(best_segs{i,j},2)
                for k=1:length(img_names)
                    img_ext = get_img_extension([SVMSEGMopts.exp_dir '/JPEGImages/' directories{k} '/' img_names{k}]);
                    I = imread([SVMSEGMopts.exp_dir '/JPEGImages/' directories{k} '/' img_names{k} img_ext]);
                    track_dir = [SVMSEGMopts.exp_dir 'MySegmentTracks/' mask_type '/CSI/' directories{k} '/' int2str(ii) '/'];
                    if ~exist(track_dir,'dir')
                        mkdir(track_dir);
                    end
                    merged_img = merge_img(best_segs{i,j}{k,ii}, I);
                    cmap = [0 0 0;1 1 1];
                    imwrite(best_segs{i,j}{k,ii}, cmap, [track_dir num2str(k) '.png']);
                    imwrite(merged_img, [track_dir num2str(k) '.jpg']);
                end
            end
            
            if nargout > 0 && exist('quality_type','var') && ~isempty(quality_type)
                for k=1:size(best_segs{i,j},2)
                    qual_track{k} = cell2mat(compute_segment_qualities(SVMSEGMopts.exp_dir, directories, img_names, best_segs{i,j}(:,k), quality_type));
                    if size(qual_track{k},2) > 1
                        if i==1 && j==1 && k==1
                            mq = zeros(length(weight_grid), length(reg_grid), size(w,2), size(qual_track{k},2));
                        end
                        mq(i,j,k,:) = mean(qual_track{k},1);
                    else
                        mq(i,j,k) = mean(cell2mat(qual_track(:,k)),1);
                    end
                end
            end
            mq
        end
    end
end